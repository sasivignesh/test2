 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/p2p/p2p_call.c b/p2p/p2p_call.c
index 5e67e5587149c911294a82db610b7d8467ea2d23..a4f1a220f1b8b7c4d37a948704400111735139be 100644
--- a/p2p/p2p_call.c
+++ b/p2p/p2p_call.c
@@ -64,52 +64,56 @@ static void *send_thread(void *p) {
                 rtp_session_sendm_with_ts(c->rtp, mp, ts);
             } else freemsg(mp);
             ts += got;
         }
     }
     return NULL;
 }
 
 int main(int argc, char **argv) {
     if (argc != 2) { fprintf(stderr, "usage: %s <peer_ip>\n", argv[0]); return 1; }
     const char *peer_ip = argv[1];
 
     ortp_init();
     rtp_profile_set_payload(&av_profile,0,&payload_type_pcmu8000);
     RtpSession *rtp = rtp_session_new(RTP_SESSION_SENDRECV);
     rtp_session_set_local_addr(rtp,"0.0.0.0",5004,5005);
     rtp_session_set_remote_addr(rtp, peer_ip,5004);
     rtp_session_enable_rtcp(rtp,1);
 
     bzrtpContext_t *zctx = bzrtp_createBzrtpContext();
     RtpUserData ud = { rtp, NULL };
     bzrtpCallbacks_t cbs = {0};
     cbs.bzrtp_sendData = rtp_send;
     cbs.bzrtp_startSrtpSession = start_srtp;
     bzrtp_setCallbacks(zctx,&cbs);
-    bzrtp_setClientData(zctx,0x1234, &ud);
     bzrtp_initBzrtpContext(zctx,0x1234);
+    int rc = bzrtp_setClientData(zctx,0x1234, &ud);
+    if (rc != 0) {
+        fprintf(stderr, "bzrtp_setClientData failed: %d\n", rc);
+        return 1;
+    }
     bzrtp_startChannelEngine(zctx,0x1234);
 
     while (ud.srtp == NULL) {
         mblk_t *mp = rtp_session_recvm_with_ts(rtp,0);
         if (mp) {
             uint8_t *pkt = mp->b_rptr;
             int len = msgdsize(mp);
             if (rtp_get_payload_type(mp)==ZRTP_PAYLOAD_TYPE)
                 bzrtp_processMessage(zctx,0x1234,pkt,len);
             freemsg(mp);
         }
         bzrtp_iterate(zctx,0x1234,ortp_get_cur_time_ms());
     }
 
     snd_pcm_t *cap, *play;
     snd_pcm_open(&cap, "default", SND_PCM_STREAM_CAPTURE, 0);
     snd_pcm_open(&play, "default", SND_PCM_STREAM_PLAYBACK, 0);
     snd_pcm_set_params(cap, SND_PCM_FORMAT_S16_LE, SND_PCM_ACCESS_RW_INTERLEAVED, 1, 8000, 1, 500000);
     snd_pcm_set_params(play, SND_PCM_FORMAT_S16_LE, SND_PCM_ACCESS_RW_INTERLEAVED, 1, 8000, 1, 500000);
 
     struct send_ctx ctx = { rtp, ud.srtp, cap };
     pthread_t tid;
     pthread_create(&tid, NULL, send_thread, &ctx);
 
     while (1) {
 
EOF
)
